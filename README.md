# Using Sass to workaround the mobile first IE8 view issue

## Introduction
When following the responsive, mobile first methodology, there's always an issue of how to support those browsers which don't have media query support, such as IE8. Some advocate serving up a modified version of the mobile view to such browsers. While others advocate the use of JavaScript polyfills, such as [respond.js](https://github.com/scottjehl/Respond) to emulate media queries. The latter goes some way to solving this issue, but also raises a few of its own, notably performance and the reliance on JavaScript.

### An alternative approach

My approach utilises Sass mixins and modular media queries so you can continue building mobile first as you normally would, but lets you choose a specific view to fallback to for &lt;=IE8 and other non-supporting browsers.

For this example I will be discussing IE8 and below.

### Usage

Carry on building mobile first, but when you reach for the media queries, instead of using the CSS3 `@media (only screen...)` expressions, you `@include` the Sass `media-query` mixin below:

```scss
@include media-query( wide ){
	width: 25%;
};
```

The key factor of what makes this work is its reliance on *named* media queries. Normally you would use media queries with explicit properties, such as `@media (only screen min-width 320px)...`. With this approach, we are using named media queries, stored in a linked-list within a Sass variable to include pre-defined media queries:

``` scss
$media-query-ids: narrow, medium, wide, superwide;
$media-queries: "only screen and (max-width: 320px)",
		"only screen and (min-width: 600px)",
		"only screen and (min-width: 960px)",
		"only screen and (min-width: 1280px)";
```

A handy helper function then picks the right media query for us. 

``` scss
@function get-item-by-name( $name, $names-list, $items ){
	@return #{ nth( $items, index( $names-list, $name ) ) };
}
```

*Note: Incidentally, this technique is also helpful for specifying font stacks by name.*

This is the mixin as it stands. It takes two parameters, the first is the `breakpoint` (string) param. *Note: For future reference: this is going to change as it self-limiting and misleading in that it only describes breakpoints, and isn't inclusive of device-pixel queries and other such matter)*. The second is the `include` (boolean) param. This is set to `true` by default but when set to `false` doens't include `@content` for non-mq supporting browsers that match the default view.

``` scss
// @media-query
// $breakpoint (string) Breakpoint ID
// $include (boolean) Flag to include @content
@mixin media-query( $breakpoint, $include: true ){
	$media-query : get-item-by-name( $breakpoint, $media-query-ids, $media-queries );
	@if $supports-mq {
		@media #{ $media-query } { @content; };
	}
	@else {
		@if $breakpoint == $default-breakpoint {
			@if $include {
				@content;
			}
		}
	}
}
```

Further example of the predefined media queries in action:

``` scss
.col{
	/* My Mobile first styles*/
	background: #000;
	color: #fff;
	font-weight: bold;
	padding: 10px;
	
	@include media-query( wide ){
		float: left;
		padding: 10px;
		width: 25%;
	};
	@include media-query( superwide ){
		float: left;
		width: 12.5%;
	};
}
```

In our site we have two main stylesheets (could be as many as you like really but I'm keeping it simple): `ie.css` (for IE) and `main.css` (for those that support media queries). These are generated by Sass from `ie.scss` and `main.scss`. Each of these has the flag `$supports-mq`, which is set to `true` for `main.scss` and `false` for `ie.scss`.

**ie.scss**
```
$supports-mq: false;
$default-breakpoint: wide;

@import "_styles";
```

**base.scss**
```
$supports-mq: true;

@import "_styles";
```

### More to followâ€¦
...

#### Credits
By Justin Perry, 2013
